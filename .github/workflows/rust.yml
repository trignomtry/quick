name: Rust

permissions:
  contents: write # Allows creating or editing releases

on:
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always
  LLVM_TAG: llvmorg-18.1.4
  ZSTD_VERSION: 1.5.6
  DEPS_PREFIX: ${{ github.workspace }}/deps/install
  LLVM_PREFIX: ${{ github.workspace }}/llvm
  LLVM_SYS_181_PREFIX: ${{ github.workspace }}/llvm

jobs:
  build:
    name: ${{ matrix.name }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: linux-x86_64
            runner: ubuntu-22.04
            os_id: linux
            arch: x86_64
            target: x86_64-unknown-linux-gnu
            bin_ext: ""
            package: tar
            rustflags: ""
          - name: macos-arm64
            runner: macos-14
            os_id: darwin
            arch: arm64
            target: aarch64-apple-darwin
            bin_ext: ""
            package: tar
            rustflags: ""
          - name: macos-x86_64
            runner: macos-14
            os_id: darwin
            arch: x86_64
            target: x86_64-apple-darwin
            bin_ext: ""
            package: tar
            rustflags: ""
          - name: windows-x86_64
            runner: windows-latest
            os_id: windows
            arch: x86_64
            target: x86_64-pc-windows-msvc
            bin_ext: ".exe"
            package: zip
            rustflags: ""

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        shell: bash
        run: |
          set -euo pipefail
          VERSION=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[] | select(.name=="quick") | .version')
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "VERSION=${VERSION}" >> "$GITHUB_ENV"

      - name: Cache LLVM/zstd build (non-Windows)
        if: runner.os != 'Windows'
        id: cache-llvm
        uses: actions/cache@v4
        with:
          path: deps/install
          key: llvm-zstd-${{ runner.os }}-${{ matrix.arch }}-${{ env.LLVM_TAG }}

      - name: Cache LLVM build (Windows)
        if: runner.os == 'Windows'
        id: cache-llvm-win
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/llvm
          key: llvm-win-${{ matrix.arch }}-${{ env.LLVM_TAG }}

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: nightly
          targets: ${{ matrix.target }}

      - name: Free disk space (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo rm -rf /usr/share/dotnet /opt/ghc /opt/hostedtoolcache/CodeQL || true
          sudo rm -rf /opt/hostedtoolcache/go /opt/hostedtoolcache/Python /opt/hostedtoolcache/Ruby || true
          sudo rm -rf /opt/google/chrome /usr/local/lib/android /usr/local/share/boost /home/linuxbrew || true
          docker system prune -af || true
          df -h

      - name: Install build dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential musl-tools zstd libzstd-dev xz-utils pkg-config libtinfo5 libncurses5 ninja-build

      - name: Enable Rosetta for x86 build (macOS)
        if: runner.os == 'macOS' && matrix.arch == 'x86_64'
        run: softwareupdate --install-rosetta --agree-to-license

      - name: Build zstd from source (static)
        if: runner.os != 'Windows' && steps.cache-llvm.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          mkdir -p "${DEPS_PREFIX}"
          ARCH_FLAG=""
          if [ "${{ runner.os }}" = "macOS" ]; then
            ARCH_FLAG="-DCMAKE_OSX_ARCHITECTURES=${{ matrix.arch }}"
          fi
          curl -fsSL -o /tmp/zstd.tar.gz "https://github.com/facebook/zstd/releases/download/v${ZSTD_VERSION}/zstd-${ZSTD_VERSION}.tar.gz"
          tar xzf /tmp/zstd.tar.gz -C /tmp
          cmake -S "/tmp/zstd-${ZSTD_VERSION}/build/cmake" -B /tmp/zstd-build \
            -DZSTD_BUILD_SHARED=OFF -DZSTD_BUILD_STATIC=ON -DCMAKE_POSITION_INDEPENDENT_CODE=ON \
            -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="${DEPS_PREFIX}" ${ARCH_FLAG}
          cmake --build /tmp/zstd-build --config Release --target install

      - name: Build LLVM + libunwind from source (static)
        if: runner.os != 'Windows' && steps.cache-llvm.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          ARCH_FLAG=""
          if [ "${{ runner.os }}" = "macOS" ]; then
            ARCH_FLAG="-DCMAKE_OSX_ARCHITECTURES=${{ matrix.arch }}"
          fi
          git clone --depth 1 --branch "${LLVM_TAG}" https://github.com/llvm/llvm-project.git /tmp/llvm-project
          cmake -G Ninja -S /tmp/llvm-project/llvm -B /tmp/llvm-build \
            -DLLVM_TARGETS_TO_BUILD="X86;AArch64" \
            -DLLVM_ENABLE_PROJECTS="clang;lld" \
            -DLLVM_ENABLE_RUNTIMES="libunwind" \
            -DLLVM_BUILD_LLVM_DYLIB=OFF -DLLVM_LINK_LLVM_DYLIB=OFF \
            -DBUILD_SHARED_LIBS=OFF -DLLVM_ENABLE_TERMINFO=OFF -DLLVM_ENABLE_LIBXML2=OFF \
            -DLLVM_ENABLE_ZSTD=OFF -DLLVM_ENABLE_ZLIB=OFF \
            -DLIBUNWIND_ENABLE_SHARED=OFF -DCMAKE_POSITION_INDEPENDENT_CODE=ON \
            -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="${DEPS_PREFIX}" ${ARCH_FLAG}
          cmake --build /tmp/llvm-build --config Release --target install
          echo "${DEPS_PREFIX}/bin" >> "$GITHUB_PATH"

      - name: Install LLVM (Windows)
        if: matrix.os_id == 'windows' && steps.cache-llvm-win.outputs.cache-hit != 'true'
        shell: pwsh
        env:
          LLVM_TAG: ${{ env.LLVM_TAG }}
        run: |
          $ErrorActionPreference = 'Stop'
          $version = $env:LLVM_TAG.TrimStart('llvmorg-')
          $dest = Join-Path $env:GITHUB_WORKSPACE "llvm"
          New-Item -ItemType Directory -Force -Path $dest | Out-Null

          # Try official installer
          $installer = "https://github.com/llvm/llvm-project/releases/download/$($env:LLVM_TAG)/LLVM-$version-win64.exe"
          $exePath = Join-Path $env:GITHUB_WORKSPACE "llvm-installer.exe"
          Invoke-WebRequest -Uri $installer -OutFile $exePath
          Start-Process -FilePath $exePath -ArgumentList "/S","/D=$dest" -Wait
          Remove-Item $exePath -Force

          # The official Windows installer does not ship llvm-config.exe.
          # We still use the installed toolchain and headers for llvm-sys by
          # pointing LLVM_SYS_181_PREFIX/LLVM_PREFIX at the install root.
          $binDir = Join-Path $dest "bin"
          if (-not (Test-Path $binDir)) {
            Write-Error "LLVM bin directory not found at $binDir"
          }

          $cmakeConfig = Join-Path $dest "lib/cmake/llvm/LLVMConfig.cmake"
          if (-not (Test-Path $cmakeConfig)) {
            Write-Warning "LLVMConfig.cmake not found in installer; building LLVM from source with MSVC"
            $srcDir = Join-Path $env:GITHUB_WORKSPACE "llvm-project"
            $buildDir = Join-Path $env:GITHUB_WORKSPACE "llvm-build"
            if (Test-Path $srcDir) { Remove-Item $srcDir -Recurse -Force }
            if (Test-Path $buildDir) { Remove-Item $buildDir -Recurse -Force }
            git clone --depth 1 --branch $env:LLVM_TAG https://github.com/llvm/llvm-project.git $srcDir
            cmake -G "Visual Studio 17 2022" -A x64 -S "$srcDir/llvm" -B $buildDir `
              -DLLVM_TARGETS_TO_BUILD="X86" `
              -DLLVM_ENABLE_PROJECTS="clang;lld" `
              -DLLVM_BUILD_LLVM_DYLIB=OFF -DLLVM_LINK_LLVM_DYLIB=OFF `
              -DBUILD_SHARED_LIBS=OFF -DLLVM_ENABLE_TERMINFO=OFF -DLLVM_ENABLE_LIBXML2=OFF `
              -DLLVM_ENABLE_ZSTD=OFF -DLLVM_ENABLE_ZLIB=OFF `
              -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="$dest"
            cmake --build $buildDir --config Release --target install
            if (-not (Test-Path $cmakeConfig)) {
              Write-Error "LLVMConfig.cmake not found after source build"
            }
          }

          "LLVM_PREFIX=$dest" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "LLVM_SYS_181_PREFIX=$dest" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Add LLVM to PATH (Windows)
        if: matrix.os_id == 'windows'
        shell: pwsh
        run: |
          $dest = if ($env:LLVM_PREFIX) { $env:LLVM_PREFIX } else { Join-Path $env:GITHUB_WORKSPACE "llvm" }
          echo "$dest\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Ensure libxml2 import lib (Windows)
        if: matrix.os_id == 'windows'
        shell: pwsh
        env:
          LLVM_PREFIX: ${{ env.LLVM_PREFIX }}
        run: |
          $libDir = Join-Path $env:LLVM_PREFIX "lib"
          $xml = Join-Path $libDir "libxml2.lib"
          $xmls = Join-Path $libDir "libxml2s.lib"
          if ((Test-Path $xml) -and -not (Test-Path $xmls)) {
            Copy-Item $xml $xmls -Force
            Write-Host "Created libxml2s.lib from libxml2.lib"
          }

      - name: Build release (non-Windows)
        if: runner.os != 'Windows'
        shell: bash
        env:
          LLVM_PREFIX: ${{ env.DEPS_PREFIX }}
          LLVM_SYS_181_PREFIX: ${{ env.DEPS_PREFIX }}
          LLVM_CONFIG_PATH: ${{ env.DEPS_PREFIX }}/bin/llvm-config
          LIBRARY_PATH: ${{ env.DEPS_PREFIX }}/lib
          LD_LIBRARY_PATH: ${{ env.DEPS_PREFIX }}/lib
          DYLD_LIBRARY_PATH: ${{ env.DEPS_PREFIX }}/lib
          RUSTFLAGS: ${{ matrix.rustflags }}
          CARGO_TARGET_DIR: ${{ github.workspace }}/target
        run: |
          set -euo pipefail
          NEW_RUSTFLAGS="${RUSTFLAGS:-}"
          if [ "${{ runner.os }}" = "Linux" ]; then
            export CC="${LLVM_PREFIX}/bin/clang"
            export CXX="${LLVM_PREFIX}/bin/clang++"
            export AR="${LLVM_PREFIX}/bin/llvm-ar"
            export RANLIB="${LLVM_PREFIX}/bin/llvm-ranlib"
            NEW_RUSTFLAGS="${NEW_RUSTFLAGS:+${NEW_RUSTFLAGS} }-C link-arg=-fuse-ld=lld"
          else
            export SDKROOT="$(xcrun --sdk macosx --show-sdk-path)"
            if [ -x "${LLVM_PREFIX}/bin/clang" ] && [ -x "${LLVM_PREFIX}/bin/ld.lld" ]; then
              export CC="${LLVM_PREFIX}/bin/clang"
              export CXX="${LLVM_PREFIX}/bin/clang++"
              export AR="${LLVM_PREFIX}/bin/llvm-ar"
              export RANLIB="${LLVM_PREFIX}/bin/llvm-ranlib"
            fi
          fi
          export RUSTFLAGS="$NEW_RUSTFLAGS"
          # Build host runtime to stage for build.rs
          cargo build --locked --release --lib --features runtime-lib --target ${{ matrix.target }}
          host_lib="target/${{ matrix.target }}/release/libquick_runtime.a"
          if [ ! -f "$host_lib" ]; then
            alt_host="target/${{ matrix.target }}/release/libquick.a"
            if [ -f "$alt_host" ]; then
              host_lib="$alt_host"
            else
              echo "Host runtime archive not found at $host_lib" >&2
              exit 1
            fi
          fi
          # Stage host runtime where build.rs expects it
          mkdir -p target/release
          cp "$host_lib" target/release/libquick_runtime.a
          # Build target runtime
          cargo build --locked --release --lib --features runtime-lib --target ${{ matrix.target }}
          lib_path="target/${{ matrix.target }}/release/libquick_runtime.a"
          if [ ! -f "$lib_path" ]; then
            # Fallback to old name if present
            alt_path="target/${{ matrix.target }}/release/libquick.a"
            if [ -f "$alt_path" ]; then
              lib_path="$alt_path"
            else
              echo "Static library not found at $lib_path or $alt_path" >&2
              exit 1
            fi
          fi
          mkdir -p build target/runtime/release
          cp "$lib_path" build/libquick_runtime.a
          cp "$lib_path" target/runtime/release/libquick_runtime.a
          # Ensure build.rs sees a staged runtime archive
          if [ "$lib_path" != "target/release/libquick_runtime.a" ]; then
            mkdir -p target/release
            cp "$lib_path" target/release/libquick_runtime.a
          fi
          # Build host binary (uses staged host runtime)
          cargo build --locked --release
          # Build target binary
          cargo build --locked --release --target ${{ matrix.target }}

      - name: Build release (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          LLVM_PREFIX: ${{ env.LLVM_PREFIX }}
          LLVM_SYS_181_PREFIX: ${{ env.LLVM_SYS_181_PREFIX }}
          LLVM_CONFIG_PATH: ${{ env.LLVM_PREFIX }}/bin/llvm-config
          LLVM_NO_LIBXML2: "1"
          RUSTFLAGS: ${{ matrix.rustflags }}
          CARGO_TARGET_DIR: ${{ github.workspace }}/target
        run: |
          $ErrorActionPreference = 'Stop'
          cargo build --locked --release --lib --features runtime-lib --target ${{ matrix.target }}
          $libPath = "target/${{ matrix.target }}/release/libquick_runtime.a"
          $altPath = "target/${{ matrix.target }}/release/libquick.a"
          $altPath2 = "target/${{ matrix.target }}/release/quick.lib"
          $altPath3 = "target/${{ matrix.target }}/release/quick_runtime.lib"
          if (-not (Test-Path $libPath)) {
            if (Test-Path $altPath) {
              $libPath = $altPath
            } elseif (Test-Path $altPath2) {
              $libPath = $altPath2
            } elseif (Test-Path $altPath3) {
              $libPath = $altPath3
            } else {
              Write-Host "--- Listing files in target/${{ matrix.target }}/release/ ---"
              Get-ChildItem -Path "target/${{ matrix.target }}/release/"
              Write-Error "Static library not found at $libPath or $altPath or $altPath2 or $altPath3"
            }
          }
          New-Item -ItemType Directory -Force -Path build | Out-Null
          Copy-Item $libPath build/libquick_runtime.a -Force
          $runtimeDir = Join-Path $env:GITHUB_WORKSPACE "target/runtime/release"
          New-Item -ItemType Directory -Force -Path $runtimeDir | Out-Null
          Copy-Item $libPath (Join-Path $runtimeDir "libquick_runtime.a") -Force
          # Place where build.rs expects it when running host tools
          New-Item -ItemType Directory -Force -Path (Join-Path $env:GITHUB_WORKSPACE "target/release") | Out-Null
          Copy-Item $libPath (Join-Path $env:GITHUB_WORKSPACE "target/release/libquick_runtime.a") -Force
          cargo build --locked --release --target ${{ matrix.target }}

      - name: Package artifact (Linux/macOS)
        if: matrix.os_id != 'windows'
        id: package-unix
        run: |
          set -euo pipefail
          ARTIFACT_BASE="quick-${{ matrix.os_id }}-${{ matrix.arch }}"
          TARGET_DIR="target/${{ matrix.target }}/release"
          BIN_SRC="${TARGET_DIR}/quick${{ matrix.bin_ext }}"
          OUT_DIR="${GITHUB_WORKSPACE}/dist/${{ matrix.name }}"
          BIN_DIR="${OUT_DIR}/bin"
          mkdir -p "${OUT_DIR}" "${BIN_DIR}"

          cp "${BIN_SRC}" "${OUT_DIR}/${ARTIFACT_BASE}${{ matrix.bin_ext }}"
          cp "${BIN_SRC}" "${BIN_DIR}/quick${{ matrix.bin_ext }}"

          LIB_SRC=""
          if compgen -G "${TARGET_DIR}/libquick_runtime.*" > /dev/null; then
            LIB_SRC=$(ls "${TARGET_DIR}/libquick_runtime."* | head -n1)
          elif compgen -G "${TARGET_DIR}/libquick.*" > /dev/null; then
            LIB_SRC=$(ls "${TARGET_DIR}/libquick."* | head -n1)
          elif compgen -G "${TARGET_DIR}/quick.*" > /dev/null; then
            LIB_SRC=$(ls "${TARGET_DIR}/quick."* | head -n1)
          fi

          LIB_ENTRY=""
          if [ -n "${LIB_SRC}" ]; then
            cp "${LIB_SRC}" "${OUT_DIR}/$(basename "${LIB_SRC}")"
            cp "${LIB_SRC}" "${BIN_DIR}/libquick.a"
            LIB_ENTRY="bin/libquick.a"
          fi

          entries=("${ARTIFACT_BASE}${{ matrix.bin_ext }}" "bin/quick${{ matrix.bin_ext }}")
          if [ -n "${LIB_ENTRY}" ]; then
            entries+=("${LIB_ENTRY}")
          fi

          if [ -x "${DEPS_PREFIX}/bin/clang" ]; then
            mkdir -p "${OUT_DIR}/llvm/bin"
            cp "${DEPS_PREFIX}/bin/clang" "${OUT_DIR}/llvm/bin/"
            if [ -x "${DEPS_PREFIX}/bin/ld.lld" ]; then
              cp "${DEPS_PREFIX}/bin/ld.lld" "${OUT_DIR}/llvm/bin/"
            fi
            if [ -x "${DEPS_PREFIX}/bin/lld" ]; then
              cp "${DEPS_PREFIX}/bin/lld" "${OUT_DIR}/llvm/bin/"
            fi
            entries+=("llvm")
          fi

          tar -czf "${OUT_DIR}/${ARTIFACT_BASE}.tar.gz" -C "${OUT_DIR}" "${entries[@]}"
          echo "asset=${OUT_DIR}/${ARTIFACT_BASE}.tar.gz" >> "$GITHUB_OUTPUT"

      - name: Package artifact (Windows)
        if: matrix.os_id == 'windows'
        id: package-win
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $artifactBase = "quick-${{ matrix.os_id }}-${{ matrix.arch }}"
          $targetDir = Join-Path $env:GITHUB_WORKSPACE "target/${{ matrix.target }}/release"
          $outDir = Join-Path $env:GITHUB_WORKSPACE "dist/${{ matrix.name }}"
          $binDir = Join-Path $outDir "bin"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null
          New-Item -ItemType Directory -Force -Path $binDir | Out-Null

          $binSrc = Join-Path $targetDir "quick${{ matrix.bin_ext }}"
          Copy-Item $binSrc (Join-Path $outDir "$artifactBase${{ matrix.bin_ext }}")
          Copy-Item $binSrc (Join-Path $binDir "quick${{ matrix.bin_ext }}")

          $libSrc = Get-ChildItem -Path $targetDir -Filter "libquick_runtime.*" -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $libSrc) {
            $libSrc = Get-ChildItem -Path $targetDir -Filter "libquick.*" -ErrorAction SilentlyContinue | Select-Object -First 1
          }
          if (-not $libSrc) {
            $libSrc = Get-ChildItem -Path $targetDir -Filter "quick.*" -ErrorAction SilentlyContinue | Select-Object -First 1
          }

          $entries = @("$artifactBase${{ matrix.bin_ext }}", "bin/quick${{ matrix.bin_ext }}")
          if ($libSrc) {
            Copy-Item $libSrc.FullName (Join-Path $outDir $libSrc.Name)
            Copy-Item $libSrc.FullName (Join-Path $binDir "libquick.a") -Force
            $entries += "bin/libquick.a"
            # Ensure embed path exists for Windows builds too
            $runtimeDir = Join-Path $env:GITHUB_WORKSPACE "target/runtime/release"
            New-Item -ItemType Directory -Force -Path $runtimeDir | Out-Null
            Copy-Item $libSrc.FullName (Join-Path $runtimeDir "libquick_runtime.a") -Force
          }

          $zipPath = Join-Path $outDir "$artifactBase.zip"
          Push-Location $outDir
          Compress-Archive -Path $entries -DestinationPath $zipPath -Force
          Pop-Location
          "asset=$zipPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}
          path: ${{ steps.package-unix.outputs.asset || steps.package-win.outputs.asset }}

      - name: Publish release asset
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.VERSION }}
          name: v${{ env.VERSION }}
          files: ${{ steps.package-unix.outputs.asset || steps.package-win.outputs.asset }}
          fail_on_unmatched_files: true

  build-linux-arm64-cross:
    name: linux-arm64-cross
    runs-on: ubuntu-22.04
    env:
      CARGO_TERM_COLOR: always
      LLVM_TAG: llvmorg-18.1.4
      ZSTD_VERSION: 1.5.6
      DEPS_PREFIX: ${{ github.workspace }}/deps/install
      LLVM_PREFIX: /usr/lib/llvm-18
      LLVM_SYS_181_PREFIX: /usr/lib/llvm-18
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        shell: bash
        run: |
          set -euo pipefail
          VERSION=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[] | select(.name=="quick") | .version')
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "VERSION=${VERSION}" >> "$GITHUB_ENV"

      - name: Build and package (ARM64 via emulation)
        uses: uraimo/run-on-arch-action@v2
        with:
          arch: aarch64
          distro: ubuntu22.04
          githubToken: ${{ github.token }}
          install: |
            set -euo pipefail
            apt-get update
            apt-get install -y curl build-essential pkg-config libtinfo5 libncurses5 zstd libzstd-dev zlib1g-dev xz-utils gnupg software-properties-common ca-certificates jq lsb-release
            curl -fsSL https://apt.llvm.org/llvm.sh -o /tmp/llvm.sh
            chmod +x /tmp/llvm.sh
            /tmp/llvm.sh 18
            apt-get update
            apt-get install -y llvm-18-dev libpolly-18-dev clang-18 lld-18
            curl https://sh.rustup.rs -sSf | sh -s -- -y --default-toolchain nightly --profile minimal
          run: |
            set -euo pipefail
            . "$HOME/.cargo/env"
            export LLVM_PREFIX="/usr/lib/llvm-18"
            export LLVM_SYS_181_PREFIX="/usr/lib/llvm-18"
            export LLVM_CONFIG_PATH="/usr/bin/llvm-config-18"
            export LLVM_SYS_181_POLLY=OFF
            export DEPS_PREFIX="${GITHUB_WORKSPACE}/deps/install"
            export CARGO_TARGET_DIR="${GITHUB_WORKSPACE}/target"
            export CARGO_BUILD_JOBS=1
            rustup target add aarch64-unknown-linux-gnu
            export CC="clang-18"
            export CXX="clang++-18"
            export AR="llvm-ar-18"
            export RANLIB="llvm-ranlib-18"
            export LLVM_CONFIG_PATH="/usr/bin/llvm-config-18"
            export LIBRARY_PATH="/usr/lib/llvm-18/lib"
            export LD_LIBRARY_PATH="/usr/lib/llvm-18/lib"

            # Build host runtime and stage for build.rs
            cargo build --locked --release --lib --features runtime-lib
            host_lib="target/release/libquick_runtime.a"
            if [ ! -f "$host_lib" ]; then
              echo "Host runtime archive not found at $host_lib" >&2
              exit 1
            fi

            # Build target runtime
            cargo build --locked --release --lib --features runtime-lib --target aarch64-unknown-linux-gnu
            lib_path="target/aarch64-unknown-linux-gnu/release/libquick_runtime.a"
            if [ ! -f "$lib_path" ]; then
              alt="target/aarch64-unknown-linux-gnu/release/libquick.a"
              if [ -f "$alt" ]; then
                lib_path="$alt"
              else
                echo "Static library not found" >&2
                exit 1
              fi
            fi

            mkdir -p build target/runtime/release
            cp "$lib_path" build/libquick_runtime.a
            cp "$lib_path" target/runtime/release/libquick_runtime.a

            # Stage runtime where build.rs expects it (ensure present)
            if [ ! -f target/release/libquick_runtime.a ]; then
              mkdir -p target/release
              cp "$lib_path" target/release/libquick_runtime.a
            fi

            cargo build --locked --release --target aarch64-unknown-linux-gnu

            ARTIFACT_BASE="quick-linux-arm64"
            TARGET_DIR="target/aarch64-unknown-linux-gnu/release"
            OUT_DIR="${GITHUB_WORKSPACE}/dist/linux-arm64"
            BIN_SRC="${TARGET_DIR}/quick"
            mkdir -p "$OUT_DIR" "$OUT_DIR/bin"
            cp "$BIN_SRC" "$OUT_DIR/${ARTIFACT_BASE}"
            cp "$BIN_SRC" "$OUT_DIR/bin/quick"
            cp "$lib_path" "$OUT_DIR/bin/libquick.a"

            LLVM_BIN="/usr/lib/llvm-18/bin"
            if [ -x "$LLVM_BIN/clang" ]; then
              mkdir -p "$OUT_DIR/llvm/bin"
              cp "$LLVM_BIN/clang" "$OUT_DIR/llvm/bin/"
              if [ -x "$LLVM_BIN/ld.lld" ]; then
                cp "$LLVM_BIN/ld.lld" "$OUT_DIR/llvm/bin/"
              fi
              if [ -x "$LLVM_BIN/lld" ]; then
                cp "$LLVM_BIN/lld" "$OUT_DIR/llvm/bin/"
              fi
              if [ -x "$LLVM_BIN/llvm-ar" ]; then
                cp "$LLVM_BIN/llvm-ar" "$OUT_DIR/llvm/bin/"
              fi
              if [ -x "$LLVM_BIN/llvm-ranlib" ]; then
                cp "$LLVM_BIN/llvm-ranlib" "$OUT_DIR/llvm/bin/"
              fi
            fi

            entries=("${ARTIFACT_BASE}" "bin")
            if [ -d "$OUT_DIR/llvm" ]; then
              entries+=("llvm")
            fi

            tar -czf "$OUT_DIR/${ARTIFACT_BASE}.tar.gz" -C "$OUT_DIR" "${entries[@]}"
            echo "ARM artifact at $OUT_DIR/${ARTIFACT_BASE}.tar.gz"

      - name: Upload build artifact (ARM64)
        uses: actions/upload-artifact@v4
        with:
          name: linux-arm64
          path: ${{ github.workspace }}/dist/linux-arm64/quick-linux-arm64.tar.gz

      - name: Publish release asset (ARM64)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.VERSION }}
          name: v${{ env.VERSION }}
          files: ${{ github.workspace }}/dist/linux-arm64/quick-linux-arm64.tar.gz
          fail_on_unmatched_files: true

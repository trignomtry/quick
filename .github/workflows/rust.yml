name: Rust

permissions:
  contents: write # Allows creating or editing releases

on:
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always
  LLVM_TAG: llvmorg-18.1.4
  ZSTD_VERSION: 1.5.6
  DEPS_PREFIX: ${{ github.workspace }}/deps/install
  LLVM_PREFIX: ${{ github.workspace }}/llvm
  LLVM_SYS_181_PREFIX: ${{ github.workspace }}/llvm

jobs:
  build:
    name: ${{ matrix.name }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: linux-x86_64
            runner: ubuntu-22.04
            os_id: linux
            arch: x86_64
            target: x86_64-unknown-linux-gnu
            bin_ext: ""
            package: tar
            rustflags: ""
          - name: macos-arm64
            runner: macos-14
            os_id: darwin
            arch: arm64
            target: aarch64-apple-darwin
            bin_ext: ""
            package: tar
            rustflags: ""
          - name: macos-x86_64
            runner: macos-14
            os_id: darwin
            arch: x86_64
            target: x86_64-apple-darwin
            bin_ext: ""
            package: tar
            rustflags: ""
          - name: windows-x86_64
            runner: windows-latest
            os_id: windows
            arch: x86_64
            target: x86_64-pc-windows-msvc
            bin_ext: ".exe"
            package: zip
            rustflags: ""

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        shell: bash
        run: |
          set -euo pipefail
          VERSION=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[] | select(.name=="quick") | .version')
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "VERSION=${VERSION}" >> "$GITHUB_ENV"

      - name: Cache LLVM/zstd build (non-Windows)
        if: runner.os != 'Windows'
        id: cache-llvm
        uses: actions/cache@v4
        with:
          path: deps/install
          key: llvm-zstd-${{ runner.os }}-${{ matrix.arch }}-${{ env.LLVM_TAG }}

      - name: Cache LLVM build (Windows)
        if: runner.os == 'Windows'
        id: cache-llvm-win
        uses: actions/cache@v4
        with:
          path: ${{ github.workspace }}/llvm
          key: llvm-win-${{ matrix.arch }}-${{ env.LLVM_TAG }}

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: nightly
          targets: ${{ matrix.target }}

      - name: Free disk space (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo rm -rf /usr/share/dotnet /opt/ghc /opt/hostedtoolcache/CodeQL || true
          sudo rm -rf /opt/hostedtoolcache/go /opt/hostedtoolcache/Python /opt/hostedtoolcache/Ruby || true
          sudo rm -rf /opt/google/chrome /usr/local/lib/android /usr/local/share/boost /home/linuxbrew || true
          docker system prune -af || true
          df -h

      - name: Install build dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential musl-tools zstd libzstd-dev xz-utils pkg-config libtinfo5 libncurses5 ninja-build

      - name: Enable Rosetta for x86 build (macOS)
        if: runner.os == 'macOS' && matrix.arch == 'x86_64'
        run: softwareupdate --install-rosetta --agree-to-license

      - name: Build zstd from source (static)
        if: runner.os != 'Windows' && steps.cache-llvm.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          mkdir -p "${DEPS_PREFIX}"
          ARCH_FLAG=""
          if [ "${{ runner.os }}" = "macOS" ]; then
            ARCH_FLAG="-DCMAKE_OSX_ARCHITECTURES=${{ matrix.arch }}"
          fi
          curl -fsSL -o /tmp/zstd.tar.gz "https://github.com/facebook/zstd/releases/download/v${ZSTD_VERSION}/zstd-${ZSTD_VERSION}.tar.gz"
          tar xzf /tmp/zstd.tar.gz -C /tmp
          cmake -S "/tmp/zstd-${ZSTD_VERSION}/build/cmake" -B /tmp/zstd-build \
            -DZSTD_BUILD_SHARED=OFF -DZSTD_BUILD_STATIC=ON -DCMAKE_POSITION_INDEPENDENT_CODE=ON \
            -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="${DEPS_PREFIX}" ${ARCH_FLAG}
          cmake --build /tmp/zstd-build --config Release --target install

      - name: Build LLVM + libunwind from source (static)
        if: runner.os != 'Windows' && steps.cache-llvm.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          ARCH_FLAG=""
          if [ "${{ runner.os }}" = "macOS" ]; then
            ARCH_FLAG="-DCMAKE_OSX_ARCHITECTURES=${{ matrix.arch }}"
          fi
          git clone --depth 1 --branch "${LLVM_TAG}" https://github.com/llvm/llvm-project.git /tmp/llvm-project
          cmake -G Ninja -S /tmp/llvm-project/llvm -B /tmp/llvm-build \
            -DLLVM_TARGETS_TO_BUILD="X86;AArch64" \
            -DLLVM_ENABLE_PROJECTS="clang;lld" \
            -DLLVM_ENABLE_RUNTIMES="libunwind" \
            -DLLVM_BUILD_LLVM_DYLIB=OFF -DLLVM_LINK_LLVM_DYLIB=OFF \
            -DBUILD_SHARED_LIBS=OFF -DLLVM_ENABLE_TERMINFO=OFF -DLLVM_ENABLE_LIBXML2=OFF \
            -DLLVM_ENABLE_ZSTD=OFF -DLLVM_ENABLE_ZLIB=OFF \
            -DLIBUNWIND_ENABLE_SHARED=OFF -DCMAKE_POSITION_INDEPENDENT_CODE=ON \
            -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="${DEPS_PREFIX}" ${ARCH_FLAG}
          cmake --build /tmp/llvm-build --config Release --target install
          echo "${DEPS_PREFIX}/bin" >> "$GITHUB_PATH"

      - name: Install LLVM (Windows)
        if: matrix.os_id == 'windows' && steps.cache-llvm-win.outputs.cache-hit != 'true'
        shell: pwsh
        env:
          LLVM_TAG: ${{ env.LLVM_TAG }}
        run: |
          $ErrorActionPreference = 'Stop'
          $version = $env:LLVM_TAG.TrimStart('llvmorg-')
          $dest = Join-Path $env:GITHUB_WORKSPACE "llvm"
          New-Item -ItemType Directory -Force -Path $dest | Out-Null

          # Try official installer
          $installer = "https://github.com/llvm/llvm-project/releases/download/$($env:LLVM_TAG)/LLVM-$version-win64.exe"
          $exePath = Join-Path $env:GITHUB_WORKSPACE "llvm-installer.exe"
          Invoke-WebRequest -Uri $installer -OutFile $exePath
          Start-Process -FilePath $exePath -ArgumentList "/S","/D=$dest" -Wait
          Remove-Item $exePath -Force

          # The official Windows installer does not ship llvm-config.exe.
          # We still use the installed toolchain and headers for llvm-sys by
          # pointing LLVM_SYS_181_PREFIX/LLVM_PREFIX at the install root.
          $binDir = Join-Path $dest "bin"
          if (-not (Test-Path $binDir)) {
            Write-Error "LLVM bin directory not found at $binDir"
          }

          "LLVM_PREFIX=$dest" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          "LLVM_SYS_181_PREFIX=$dest" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Add LLVM to PATH (Windows)
        if: matrix.os_id == 'windows'
        shell: pwsh
        run: |
          $dest = if ($env:LLVM_PREFIX) { $env:LLVM_PREFIX } else { Join-Path $env:GITHUB_WORKSPACE "llvm" }
          echo "$dest\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Ensure libxml2 import lib (Windows)
        if: matrix.os_id == 'windows'
        shell: pwsh
        env:
          LLVM_PREFIX: ${{ env.LLVM_PREFIX }}
        run: |
          $libDir = Join-Path $env:LLVM_PREFIX "lib"
          $xml = Join-Path $libDir "libxml2.lib"
          $xmls = Join-Path $libDir "libxml2s.lib"
          if ((Test-Path $xml) -and -not (Test-Path $xmls)) {
            Copy-Item $xml $xmls -Force
            Write-Host "Created libxml2s.lib from libxml2.lib"
          }

      - name: Build release (non-Windows)
        if: runner.os != 'Windows'
        shell: bash
        env:
          LLVM_PREFIX: ${{ env.DEPS_PREFIX }}
          LLVM_SYS_181_PREFIX: ${{ env.DEPS_PREFIX }}
          LLVM_CONFIG_PATH: ${{ env.DEPS_PREFIX }}/bin/llvm-config
          LIBRARY_PATH: ${{ env.DEPS_PREFIX }}/lib
          LD_LIBRARY_PATH: ${{ env.DEPS_PREFIX }}/lib
          DYLD_LIBRARY_PATH: ${{ env.DEPS_PREFIX }}/lib
          RUSTFLAGS: ${{ matrix.rustflags }}
          CARGO_TARGET_DIR: ${{ github.workspace }}/target
        run: |
          set -euo pipefail
          NEW_RUSTFLAGS="${RUSTFLAGS:-}"
          if [ "${{ runner.os }}" = "Linux" ]; then
            export CC="${LLVM_PREFIX}/bin/clang"
            export CXX="${LLVM_PREFIX}/bin/clang++"
            export AR="${LLVM_PREFIX}/bin/llvm-ar"
            export RANLIB="${LLVM_PREFIX}/bin/llvm-ranlib"
            NEW_RUSTFLAGS="${NEW_RUSTFLAGS:+${NEW_RUSTFLAGS} }-C link-arg=-fuse-ld=lld"
          else
            export SDKROOT="$(xcrun --sdk macosx --show-sdk-path)"
            if [ -x "${LLVM_PREFIX}/bin/clang" ] && [ -x "${LLVM_PREFIX}/bin/ld.lld" ]; then
              export CC="${LLVM_PREFIX}/bin/clang"
              export CXX="${LLVM_PREFIX}/bin/clang++"
              export AR="${LLVM_PREFIX}/bin/llvm-ar"
              export RANLIB="${LLVM_PREFIX}/bin/llvm-ranlib"
            fi
          fi
          export RUSTFLAGS="$NEW_RUSTFLAGS"
          cargo build --locked --release --lib --features runtime-lib --target ${{ matrix.target }}
          lib_path="target/${{ matrix.target }}/release/libquick_runtime.a"
          if [ ! -f "$lib_path" ]; then
            # Fallback to old name if present
            alt_path="target/${{ matrix.target }}/release/libquick.a"
            if [ -f "$alt_path" ]; then
              lib_path="$alt_path"
            else
              echo "Static library not found at $lib_path or $alt_path" >&2
              exit 1
            fi
          fi
          mkdir -p build target/runtime/release
          cp "$lib_path" build/libquick_runtime.a
          cp "$lib_path" target/runtime/release/libquick_runtime.a
          cargo build --locked --release --target ${{ matrix.target }}

      - name: Build release (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          LLVM_PREFIX: ${{ env.LLVM_PREFIX }}
          LLVM_SYS_181_PREFIX: ${{ env.LLVM_SYS_181_PREFIX }}
          LLVM_CONFIG_PATH: ${{ env.LLVM_PREFIX }}/bin/llvm-config
          LLVM_NO_LIBXML2: "1"
          RUSTFLAGS: ${{ matrix.rustflags }}
          CARGO_TARGET_DIR: ${{ github.workspace }}/target
        run: |
          $ErrorActionPreference = 'Stop'
          cargo build --locked --release --lib --features runtime-lib --target ${{ matrix.target }}
          $libPath = "target/${{ matrix.target }}/release/libquick_runtime.a"
          $altPath = "target/${{ matrix.target }}/release/libquick.a"
          $altPath2 = "target/${{ matrix.target }}/release/quick.lib"
          if (-not (Test-Path $libPath)) {
            if (Test-Path $altPath) {
              $libPath = $altPath
            } elseif (Test-Path $altPath2) {
              $libPath = $altPath2
            } else {
              Write-Error "Static library not found at $libPath or $altPath or $altPath2"
            }
          }
          New-Item -ItemType Directory -Force -Path build | Out-Null
          Copy-Item $libPath build/libquick_runtime.a -Force
          $runtimeDir = Join-Path $env:GITHUB_WORKSPACE "target/runtime/release"
          New-Item -ItemType Directory -Force -Path $runtimeDir | Out-Null
          Copy-Item $libPath (Join-Path $runtimeDir "libquick_runtime.a") -Force
          cargo build --locked --release --target ${{ matrix.target }}

      - name: Package artifact (Linux/macOS)
        if: matrix.os_id != 'windows'
        id: package-unix
        run: |
          set -euo pipefail
          ARTIFACT_BASE="quick-${{ matrix.os_id }}-${{ matrix.arch }}"
          TARGET_DIR="target/${{ matrix.target }}/release"
          BIN_SRC="${TARGET_DIR}/quick${{ matrix.bin_ext }}"
          OUT_DIR="${GITHUB_WORKSPACE}/dist/${{ matrix.name }}"
          mkdir -p "${OUT_DIR}"
          cp "${BIN_SRC}" "${OUT_DIR}/${ARTIFACT_BASE}${{ matrix.bin_ext }}"

          LIB_SRC=""
          if compgen -G "${TARGET_DIR}/libquick_runtime.*" > /dev/null; then
            LIB_SRC=$(ls "${TARGET_DIR}/libquick_runtime."* | head -n1)
          elif compgen -G "${TARGET_DIR}/libquick.*" > /dev/null; then
            LIB_SRC=$(ls "${TARGET_DIR}/libquick."* | head -n1)
          elif compgen -G "${TARGET_DIR}/quick.*" > /dev/null; then
            LIB_SRC=$(ls "${TARGET_DIR}/quick."* | head -n1)
          fi

          if [ -n "${LIB_SRC}" ]; then
            cp "${LIB_SRC}" "${OUT_DIR}/$(basename "${LIB_SRC}")"
            EXTRA="$(basename "${LIB_SRC}")"
          else
            EXTRA=""
          fi

          if [ -n "${EXTRA}" ]; then
            if [ -x "${DEPS_PREFIX}/bin/clang" ]; then
              mkdir -p "${OUT_DIR}/llvm/bin"
              cp "${DEPS_PREFIX}/bin/clang" "${OUT_DIR}/llvm/bin/"
              if [ -x "${DEPS_PREFIX}/bin/ld.lld" ]; then
                cp "${DEPS_PREFIX}/bin/ld.lld" "${OUT_DIR}/llvm/bin/"
              fi
              if [ -x "${DEPS_PREFIX}/bin/lld" ]; then
                cp "${DEPS_PREFIX}/bin/lld" "${OUT_DIR}/llvm/bin/"
              fi
            fi
            tar -czf "${OUT_DIR}/${ARTIFACT_BASE}.tar.gz" -C "${OUT_DIR}" "${ARTIFACT_BASE}${{ matrix.bin_ext }}" "${EXTRA}" llvm
          else
            if [ -x "${DEPS_PREFIX}/bin/clang" ]; then
              mkdir -p "${OUT_DIR}/llvm/bin"
              cp "${DEPS_PREFIX}/bin/clang" "${OUT_DIR}/llvm/bin/"
              if [ -x "${DEPS_PREFIX}/bin/ld.lld" ]; then
                cp "${DEPS_PREFIX}/bin/ld.lld" "${OUT_DIR}/llvm/bin/"
              fi
              if [ -x "${DEPS_PREFIX}/bin/lld" ]; then
                cp "${DEPS_PREFIX}/bin/lld" "${OUT_DIR}/llvm/bin/"
              fi
              tar -czf "${OUT_DIR}/${ARTIFACT_BASE}.tar.gz" -C "${OUT_DIR}" "${ARTIFACT_BASE}${{ matrix.bin_ext }}" llvm
            else
              tar -czf "${OUT_DIR}/${ARTIFACT_BASE}.tar.gz" -C "${OUT_DIR}" "${ARTIFACT_BASE}${{ matrix.bin_ext }}"
            fi
          fi
          echo "asset=${OUT_DIR}/${ARTIFACT_BASE}.tar.gz" >> "$GITHUB_OUTPUT"

      - name: Package artifact (Windows)
        if: matrix.os_id == 'windows'
        id: package-win
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $artifactBase = "quick-${{ matrix.os_id }}-${{ matrix.arch }}"
          $targetDir = Join-Path $env:GITHUB_WORKSPACE "target/${{ matrix.target }}/release"
          $outDir = Join-Path $env:GITHUB_WORKSPACE "dist/${{ matrix.name }}"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          $binSrc = Join-Path $targetDir "quick${{ matrix.bin_ext }}"
          Copy-Item $binSrc (Join-Path $outDir "$artifactBase${{ matrix.bin_ext }}")

          $libSrc = Get-ChildItem -Path $targetDir -Filter "libquick_runtime.*" -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $libSrc) {
            $libSrc = Get-ChildItem -Path $targetDir -Filter "libquick.*" -ErrorAction SilentlyContinue | Select-Object -First 1
          }

          $entries = @((Join-Path $outDir "$artifactBase${{ matrix.bin_ext }}"))
          if ($libSrc) {
            Copy-Item $libSrc.FullName (Join-Path $outDir $libSrc.Name)
            $entries += (Join-Path $outDir $libSrc.Name)
            # Ensure embed path exists for Windows builds too
            $runtimeDir = Join-Path $env:GITHUB_WORKSPACE "target/runtime/release"
            New-Item -ItemType Directory -Force -Path $runtimeDir | Out-Null
            Copy-Item $libSrc.FullName (Join-Path $runtimeDir "libquick_runtime.a") -Force
          }

          $zipPath = Join-Path $outDir "$artifactBase.zip"
          Compress-Archive -Path $entries -DestinationPath $zipPath -Force
          "asset=$zipPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}
          path: ${{ steps.package-unix.outputs.asset || steps.package-win.outputs.asset }}

      - name: Publish release asset
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.VERSION }}
          name: v${{ env.VERSION }}
          files: ${{ steps.package-unix.outputs.asset || steps.package-win.outputs.asset }}
          fail_on_unmatched_files: true
